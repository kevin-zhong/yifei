用于：
	父线程到子线程；比如父线程要求子线程计算一个复杂式子
	一个进程到另外一个进程：比如主进程接收到用户请求，传递给业务进程处理后，得到处理结果，然后返回给用户；
	
实现：
	父只有1个，子可以1个或多个；
	子由父创建，即是真正的父子关系；
	
	线程之间的交互，采用链表即可
	进程之间的交互，采用共享内存即可
	
	通知方式，主要是根据两端的驱动类型采用不同方案：
	1）父到子，采用mutex cond即可；子到父，采用channel（子线程非事件驱动）
	2）父到子，子到父都采用 channel（父和子都是事件驱动）	
	
抽象：
	目的：屏蔽交互细节
	具体细节：
		抽象rr_bridge
	rr_bridge
	{
		__req_queue;
		__resp_queue;
		
		send_req(void* req, req_len, resp_cb, void* data);
		send_resp(void* resp, resp_len);

		get_req(void* req, req_len);
		get_resp(void* resp, resp_len);
		
		init(queue_capacity, child_num, execl, dispatch);
	}
	#define send_data(data, resp_cb, data_ptr) send_req(&data, sizeof(data), resp_cb, data_ptr)
	#define send_ptr(ptr, resp_cb, data) send_data(ptr, resp_cb, data)

进程内存数据交换：
	1，采用共享内存+页机制+页chunk数据结构(比较复杂的)；send只是一个类似指针的东西；
	2，或者比较简单的：encode 后变成二进制串，直接send；接收方解析即可；
线程内存数据交换：
	采用指针+堆内存；或者指针+发送放管理的内存（一个标志区分是否需要接收方主动释放内存）

业务必须根据自己的业务需求采用合理的交换方式；
业务必须为不同的数据交换方式采用不同的策略：
	比如如果是线程交换，那一般就会需要内存拷贝，传递指针即可，否则就需要拷贝内存到共享内存上；
	
重启分四种：
1，只重启 work proc（如果是随机分发，绝不会造成半点影响，否则会影响一点点）
2，重启 work proc + master proc（会造成极短时间内无法服务，但cache可以保持）
3，重启 work proc + master proc + cache proc（全重启，cache也清空，但保持了连接的连续性）
4，整个进程重启（什么都是新的）
	